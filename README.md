# Python vs Rust Lambda Performance Comparison

This experiment was inspired by two presentations and borrows heavily from both:

- **Lambda vs EC2 Comparison** by [Illya Kavaliou](https://github.com/ikavaliou-mg/lambda-ec2-ecs-comparison/tree/main)
- **Rustifying Serverless** by [Efi Merdler-Kravitz](https://www.youtube.com/watch?v=Mdh_2PXe9i8)

## Overview

In this experiment, I compare the performance of two simple AWS Lambda functions. 
Both functions perform the same task: generating a UUID, saving it as an object 
in an S3 bucket, and then storing the UUID in a DynamoDB table. The only 
difference is that one Lambda function is written in Rust and the other in Python.

Based on Efi's presentation, I anticipated that Rust would outperform Python, 
and I aimed to verify this through my own tests.

## Motivation

I find this topic interesting because I don't associate associate Rust with 
serverless computing and AWS Lambda, where interpreted languages like Python, 
Node.js, and TypeScript are more common. 

However, AWS's promotion of Rust for serverless applications prompted me to 
reassess my own biases. I wanted to see if icould replicate ELi's results 
using the method I'd seen Illya use in his presentation.

## Project Structure

This repository contains the files for the Python part of my experiment. Contrary to my expectations, this turned out to be the more challenging part. Surprisingly, the Rust part was easier than anticipated and did not fully represent the complexity I expected in Rust development.

## Running the Experiment

To run the Python Lambda function, follow these steps:

1. **Set Up Your Environment**:
   - Ensure you have AWS CLI configured with appropriate permissions.
   - Set the required environment variables: `S3_BUCKET_NAME` and `DYNAMODB_TABLE`.

2. Test locally using SAM
   - Use AWS SAM CLI to test the function locally.
     ```bash
     sam build
     sam deploy --guided
     ```

3. **Deploy the Lambda Function**:
    - Use the AWS CLI to deploy the function.
      ```bash
    
      ```

4. **Run Load Tests**:
   - Use k6 to run performance tests and gather data.
     ```bash
     k6 run --out json=2h_test_output.json 2h_test.js
     ```

## Findings

The experiment's results are detailed in the `2h_test_output.json` file 
generated by k6, the key findings include:

- **Performance Metrics**: Comparison of average response times, error rates, and throughput between the Rust and Python Lambda functions.
- **Resource Utilization**: Analysis of memory and CPU usage during the tests.
- **Cost Efficiency**: Examination of the cost implications of using Rust vs. Python for serverless functions on AWS.

- In all cases, Rust outperformed Python by 8-10x
- this was consistent across all metrics and resulted in similar cost savings
- Rust consumes substantially less resources than Python, evidenced by the 
  small size of the zip file, and then extending to lower CPU and memory 
  use during testing

## Developer Notes on the experiment

- Rust development was easier than expected
- Python turned out to be harder than expected
- This is not representative of my general experience with the two languages

## Conclusion

This experiment highlights the potential benefits of using 
Rust for AWS Lambda functions. 

However it's important to note that while Rust's performance advantages are 
clearly evident, the learning curve, development complexity and challenges 
with adoption within your team are significant factors to consider.

An alternative that we haven't had time to look at is a partial migration. 
User Rust for the performance-critical parts of your application, and then 
import it into your Python codebase using the PyO3 and machurin crates.

## Acknowledgments

I would like to thank Illya Kavaliou and Efi Merdler-Kravitz for their insightful presentations, which inspired this experiment.


## Contact

For any questions or feedback, please reach out to me via [LinkedIn](https://www.linkedin.com/in/michael-kenneth-kingston/).
